Adds support for Chrysalis Luna hardware

--- openssl/crypto/engine.orig/Makefile.ssl	Wed Mar 27 10:37:10 2002
+++ openssl/crypto/engine/Makefile.ssl	Wed Mar 27 10:40:16 2002
@@ -23,9 +23,9 @@
 
 LIB=$(TOP)/libcrypto.a
 LIBSRC= engine_err.c engine_lib.c engine_list.c engine_openssl.c \
-	hw_atalla.c hw_cswift.c hw_ncipher.c hw_aep.c hw_ubsec.c hw_sureware.c
+	hw_atalla.c hw_cswift.c hw_ncipher.c hw_aep.c hw_ubsec.c hw_sureware.c hw_LunaXL.c
 LIBOBJ= engine_err.o engine_lib.o engine_list.o engine_openssl.o \
-	hw_atalla.o hw_cswift.o hw_ncipher.o hw_aep.o hw_ubsec.o hw_sureware.o
+	hw_atalla.o hw_cswift.o hw_ncipher.o hw_aep.o hw_ubsec.o hw_sureware.o hw_LunaXL.o
 
 SRC= $(LIBSRC)
 
@@ -156,6 +156,26 @@
 engine_openssl.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
 engine_openssl.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
 engine_openssl.o: ../../include/openssl/symhacks.h ../cryptlib.h engine_int.h
+hw_LunaXL.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+hw_LunaXL.o: ../../include/openssl/blowfish.h ../../include/openssl/bn.h
+hw_LunaXL.o: ../../include/openssl/buffer.h ../../include/openssl/cast.h
+hw_LunaXL.o: ../../include/openssl/crypto.h ../../include/openssl/des.h
+hw_LunaXL.o: ../../include/openssl/dh.h ../../include/openssl/dsa.h
+hw_LunaXL.o: ../../include/openssl/dso.h ../../include/openssl/e_os.h
+hw_LunaXL.o: ../../include/openssl/e_os2.h ../../include/openssl/engine.h
+hw_LunaXL.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+hw_LunaXL.o: ../../include/openssl/idea.h ../../include/openssl/lhash.h
+hw_LunaXL.o: ../../include/openssl/md2.h ../../include/openssl/md4.h
+hw_LunaXL.o: ../../include/openssl/md5.h ../../include/openssl/mdc2.h
+hw_LunaXL.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+hw_LunaXL.o: ../../include/openssl/opensslconf.h
+hw_LunaXL.o: ../../include/openssl/opensslv.h ../../include/openssl/rand.h
+hw_LunaXL.o: ../../include/openssl/rc2.h ../../include/openssl/rc4.h
+hw_LunaXL.o: ../../include/openssl/rc5.h ../../include/openssl/ripemd.h
+hw_LunaXL.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+hw_LunaXL.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+hw_LunaXL.o: ../../include/openssl/symhacks.h ../cryptlib.h engine_int.h
+hw_LunaXL.o: vendor_defns/LunaXL.h
 hw_atalla.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
 hw_atalla.o: ../../include/openssl/blowfish.h ../../include/openssl/bn.h
 hw_atalla.o: ../../include/openssl/buffer.h ../../include/openssl/cast.h
diff -ruN engine.orig/engine_int.h engine/engine_int.h
--- openssl/crypto/engine.orig/engine_int.h	Wed Mar 27 10:37:10 2002
+++ openssl/crypto/engine/engine_int.h	Wed Mar 27 10:41:41 2002
@@ -166,6 +166,11 @@
 ENGINE *ENGINE_sureware();
 #endif /* !NO_HW_SUREWARE */
 
+#ifndef NO_HW_LUNA_XL
+/* Returns a structure of LunaXL methods. */
+ENGINE *ENGINE_LunaXL();
+#endif /* !NO_HW_LUNA_XL */
+
 #endif /* !NO_HW */
 
 #ifdef  __cplusplus
diff -ruN engine.orig/engine_list.c engine/engine_list.c
--- openssl/crypto/engine.orig/engine_list.c	Wed Mar 27 10:37:10 2002
+++ openssl/crypto/engine/engine_list.c	Wed Mar 27 10:42:15 2002
diff -ruN engine.orig/hw_LunaXL.c engine/hw_LunaXL.c
@@ -211,6 +211,10 @@
        if(!engine_list_add(ENGINE_sureware()))
                return 0;
 #endif /* !NO_HW_SUREWARE */
+#ifndef NO_HW_LUNA_XL
+	if(!engine_list_add(ENGINE_LunaXL()))
+		return 0;
+#endif /* !NO_HW_LUNA_XL */
 #endif /* !NO_HW */
 	engine_list_flag = 1;
 	return 1;
--- openssl/crypto/engine.orig/hw_LunaXL.c	Thu Jan  1 01:00:00 1970
+++ openssl/crypto/engine/hw_LunaXL.c	Wed Mar 27 10:40:09 2002
@@ -0,0 +1,310 @@
+/****************************************************************************\
+
+                         Chrysalis-ITS Luna XL engine
+
+ SMilinkovic
+ 1.0.2 version created July 18, 2001
+
+ Copyright (C) 2001
+ Chrysalis Information Technology Security, Inc.
+
+ All rights reserved. This file contains information that is
+ proprietary to Chrysalis ITS Inc. and may not be distributed
+ or copied without written consent from Chrysalis ITS Inc.
+
+\****************************************************************************/
+
+#include <stdio.h>
+#include <openssl/crypto.h>
+#include "cryptlib.h"
+#include <openssl/dso.h>
+#include "engine_int.h"
+#include <openssl/engine.h>
+
+#define MAX_SLOTS     32
+#ifndef NO_HW
+#ifndef NO_HW_LUNA_XL
+
+#ifdef FLAT_INC
+#include "LunaXL.h"
+#else
+#include "vendor_defns/LunaXL.h"
+#endif
+
+static DSO *LunaXL_dso = NULL;
+static int LunaXL_init(void);
+static int LunaXL_finish(void);
+static int LunaXL_rsa_priv_enc(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding);
+static int LunaXL_rsa_priv_dec(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding);
+
+static CK_SESSION_HANDLE   hSession[MAX_SLOTS];
+static CK_FLAGS     flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
+static CK_MECHANISM mech = {CKM_RSA_PKCS, NULL_PTR, 0};
+static unsigned long ulSlotCount = 1;
+int i, assigned_slot = 0;
+
+static RSA_METHOD LunaXL_rsa =
+	{
+	"PKCS#11 RSA method",
+	NULL,
+	NULL,
+	LunaXL_rsa_priv_enc,
+	LunaXL_rsa_priv_dec,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	0,
+	NULL,
+	NULL,
+	NULL
+	};
+
+static ENGINE engine_LunaXL =
+        {
+	"LunaXL",
+	"Chrysalis-ITS Luna XL engine support",
+	&LunaXL_rsa,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	LunaXL_init,
+	LunaXL_finish,
+	NULL, 		
+	NULL, 		
+	NULL, 		
+	0, 		
+	0, 0,		
+	NULL, NULL 	
+        };
+
+
+ENGINE *ENGINE_LunaXL() {
+	RSA_METHOD *method;
+	method = RSA_PKCS1_SSLeay();
+     LunaXL_rsa.rsa_pub_enc = method->rsa_pub_enc;
+     LunaXL_rsa.rsa_pub_dec = method->rsa_pub_dec;
+     LunaXL_rsa.rsa_mod_exp = method->rsa_mod_exp;	
+     LunaXL_rsa.bn_mod_exp = method->bn_mod_exp;	
+	return &engine_LunaXL;
+}
+
+
+/* The following function is for ephemeral RSA key exchange */
+static int LunaXL_E_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding) {
+	const RSA_METHOD *meth;
+	BIGNUM f,ret;
+	int j,num=0,r= -1;
+	unsigned char *p;
+	unsigned char *buf=NULL;
+	BN_CTX *ctx=NULL;
+
+	meth = ENGINE_get_RSA(rsa->engine);
+	BN_init(&f);
+	BN_init(&ret);
+	ctx=BN_CTX_new();
+	
+	if (ctx == NULL) goto err;
+    	num=BN_num_bytes(rsa->n);
+	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL){
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+     if (flen > num) {
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
+		goto err;
+	}
+
+/* convert data into a big number */
+	if (BN_bin2bn(from,(int)flen,&f) == NULL) goto err;
+	if ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))
+		RSA_blinding_on(rsa,ctx);
+	if (rsa->flags & RSA_FLAG_BLINDING)
+		if (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;
+
+/* do the decrypt */
+	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
+		((rsa->p != NULL) &&
+		(rsa->q != NULL) &&
+		(rsa->dmp1 != NULL) &&
+		(rsa->dmq1 != NULL) &&
+		(rsa->iqmp != NULL)) )
+		{ if (!meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
+	else {
+		if (!meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL))
+			goto err;
+	}
+
+	if (rsa->flags & RSA_FLAG_BLINDING)
+		if (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;
+
+	p=buf;
+	j=BN_bn2bin(&ret,p);
+
+	switch (padding) {
+	case RSA_PKCS1_PADDING:
+		r=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);
+		break;
+#ifndef NO_SHA
+        case RSA_PKCS1_OAEP_PADDING:
+	        r=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);
+                break;
+#endif
+ 	case RSA_SSLV23_PADDING:
+		r=RSA_padding_check_SSLv23(to,num,buf,j,num);
+		break;
+	case RSA_NO_PADDING:
+		r=RSA_padding_check_none(to,num,buf,j,num);
+		break;
+	default:
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+	}
+	if (r < 0)
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
+err:
+	if (ctx != NULL) BN_CTX_free(ctx);
+	BN_clear_free(&f);
+	BN_clear_free(&ret);
+	if (buf != NULL) {
+		memset(buf,0,num);
+		OPENSSL_free(buf);
+	}
+	return(r);
+}
+
+
+/* Chrystoki API hooks */
+static int LunaXL_init() {
+
+     CK_RV retCode = CKR_OK;
+
+/* Load Chrystoki libarary */
+     if(LunaXL_dso != NULL) {
+          fprintf(stderr, "  Luna XL -> Chrystoki library already loaded.\n");
+          return 0;
+     }
+
+     LunaXL_dso = DSO_load(NULL,"/usr/lib/libcrystoki2.so" , NULL, DSO_FLAG_NAME_TRANSLATION);
+     if(LunaXL_dso == NULL) {
+          fprintf(stderr, "  Luna XL -> Error loading Chrystoki library.\n");
+          return 0;
+     }
+
+     C_Initialize = (CP_Initialize)DSO_bind_func(LunaXL_dso, "C_Initialize");
+     C_Finalize   = (CP_Initialize)DSO_bind_func(LunaXL_dso, "C_Finalize");
+     C_OpenSession  = (CP_OpenSession)DSO_bind_func(LunaXL_dso, "C_OpenSession");
+     C_CloseSession = (CP_CloseSession)DSO_bind_func(LunaXL_dso, "C_CloseSession");
+     CA_SinglePartDecrypt = (CP_SinglePartDecrypt)DSO_bind_func(LunaXL_dso, "CA_SinglePartDecrypt");
+     CA_SinglePartSign    = (CP_SinglePartDecrypt)DSO_bind_func(LunaXL_dso, "CA_SinglePartSign");
+     CA_GetNumberOfSSLSlots = (CP_GetNumberOfSSLSlots)DSO_bind_func(LunaXL_dso, "CA_GetNumberOfSSLSlots");
+
+     retCode=C_Initialize(NULL_PTR);
+     if(retCode !=CKR_OK) {
+           fprintf(stderr, "  Luna XL -> Crystoki Initialize Error: 0x%x.\n", (int)retCode);
+           goto err;
+     }
+
+     retCode=CA_GetNumberOfSSLSlots(&ulSlotCount);
+     if(retCode !=CKR_OK) {
+           fprintf(stderr, "  Luna XL -> Unable to get number of slots: 0x%x.\n", (int)retCode);
+           goto err;
+     }
+
+     if(ulSlotCount > MAX_SLOTS) {
+          fprintf(stderr, "  Luna XL -> Maximum number of 32 slots exceeded.\n");
+          goto err;
+     }
+
+/* Open sessions on all available slots */
+     for(i=0; i<(int)ulSlotCount; i++) {
+          retCode = C_OpenSession((CK_SLOT_ID) (i+1),flags,"Application",0,&hSession[i]);
+          if(retCode !=CKR_OK) {
+               fprintf(stderr, "  Luna XL -> Crystoki Open Session Error: Slot number %d.\n",i+1);
+               goto err;
+          }
+     }
+     return 1;
+
+err:
+     if(LunaXL_dso)
+        DSO_free(LunaXL_dso);
+     return 0;
+}
+
+
+static int LunaXL_finish() {
+
+     CK_RV retCode = CKR_OK;
+
+     retCode=C_Finalize(NULL_PTR);
+     if(retCode !=CKR_OK) {
+           fprintf(stderr, "  Luna XL -> Crystoki Finalize Error: 0x%x.\n", (int)retCode);
+     }
+
+     if(LunaXL_dso == NULL) {
+          fprintf(stderr, "  Luna XL -> Chrystoki library not longer loaded.\n");
+          return 0;
+     }
+
+     if(!DSO_free(LunaXL_dso)) {
+          fprintf(stderr, "  Luna XL -> Can't unload Chrystoki library.\n");
+          return 0;
+     } 	
+
+     LunaXL_dso = NULL;
+  	return 1;
+}
+	
+	
+static int LunaXL_rsa_priv_enc(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding) {
+
+     CK_RV               retCode = CKR_OK;
+	CK_OBJECT_HANDLE 	hKey = 0;
+	CK_ULONG            usOutLength=128;
+
+     assigned_slot = (((unsigned int) getpid()) % (unsigned int) ulSlotCount);
+     hKey= BN_get_word(rsa->d);
+
+     retCode = CA_SinglePartSign(hSession[assigned_slot], &mech, hKey, (CK_BYTE_PTR)from, (CK_USHORT)flen, (CK_BYTE_PTR)to, &usOutLength);
+     if(retCode !=CKR_OK) {
+           fprintf(stderr, "  Luna XL-> Crystoki Single Part Sign Error: 0x%x. Slot Number: %d\n", (int)retCode, (int)(assigned_slot+1));
+           goto err;
+     }
+
+     return usOutLength;
+err:
+     return -1;
+
+}
+
+static int LunaXL_rsa_priv_dec(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding) {	
+
+     CK_RV               retCode = CKR_OK;
+	CK_OBJECT_HANDLE 	hKey = 0;
+	CK_ULONG            usOutLength=128;
+     assigned_slot = (((unsigned int) getpid()) % (unsigned int) ulSlotCount);
+
+/* Check for temporary key */
+     if(BN_num_bytes(rsa->d)>2)
+          usOutLength= LunaXL_E_private_decrypt(flen, from, to, rsa, padding);
+     else {
+/* OK, it is our key */
+          hKey= BN_get_word(rsa->d);
+          retCode = CA_SinglePartDecrypt((CK_SESSION_HANDLE)hSession[assigned_slot], &mech, hKey, (CK_BYTE_PTR)from, (CK_USHORT)flen, (CK_BYTE_PTR)to, &usOutLength);
+          if(retCode !=CKR_OK) {
+               fprintf(stderr, "  Luna XL -> Crystoki Single Part Decrypt Error: 0x%x. Slot Number: %d\n", (int)retCode, (int)(assigned_slot+1));
+               goto err;
+          }
+
+     }
+     return usOutLength;
+err:
+     return -1;
+
+}		
+
+#endif /* !NO_HW_LUNA_XL */
+#endif /* !NO_HW */
diff -ruN engine.orig/vendor_defns/LunaXL.h engine/vendor_defns/LunaXL.h
--- openssl/crypto/engine.orig/vendor_defns/LunaXL.h	Thu Jan  1 01:00:00 1970
+++ openssl/crypto/engine/vendor_defns/LunaXL.h	Wed Mar 27 10:38:00 2002
@@ -0,0 +1,61 @@
+/****************************************************************************\
+
+                         Chrysalis-ITS Luna XL engineheader
+
+ SMilinkovic
+ 1.0.2 version created July 18, 2001
+
+ Copyright (C) 2001
+ Chrysalis Information Technology Security, Inc.
+
+ All rights reserved. This file contains information that is
+ proprietary to Chrysalis ITS Inc. and may not be distributed
+ or copied without written consent from Chrysalis ITS Inc.
+
+\****************************************************************************/
+
+#define CK_PTR       *
+#define NULL_PTR     0  
+#define CK_POINTER   CK_PTR 
+#define CKR_OK       0x0000 
+#define CKM_RSA_PKCS                   0x00000001 
+#define CKF_RW_SESSION                 0x0002 
+#define CKF_SERIAL_SESSION             0x0004 
+
+typedef unsigned char                  CK_BYTE; 
+typedef unsigned long int              CK_USHORT;
+typedef unsigned long int              CK_ULONG; 
+typedef void CK_POINTER                CK_VOID_PTR; 
+typedef CK_ULONG                       CK_FLAGS; 
+typedef CK_ULONG                       CK_SLOT_ID; 
+typedef CK_BYTE CK_POINTER             CK_BYTE_PTR; 
+typedef CK_USHORT CK_POINTER           CK_USHORT_PTR; 
+typedef CK_ULONG CK_POINTER            CK_ULONG_PTR; 
+typedef CK_ULONG                       CK_SESSION_HANDLE; 
+typedef CK_SESSION_HANDLE CK_POINTER   CK_SESSION_HANDLE_PTR; 
+typedef CK_ULONG                       CK_OBJECT_HANDLE; 
+typedef CK_USHORT                      CK_MECHANISM_TYPE; 
+
+typedef struct CK_MECHANISM { 
+   CK_MECHANISM_TYPE mechanism; 
+   CK_VOID_PTR pParameter; 
+   CK_ULONG ulParameterLen; 
+   }CK_MECHANISM; 
+
+typedef CK_MECHANISM CK_POINTER        CK_MECHANISM_PTR; 
+typedef CK_USHORT                      CK_RV; 
+
+typedef CK_RV (*CP_Initialize)(CK_VOID_PTR);
+typedef CK_RV (*CP_GetNumberOfSSLSlots)(CK_ULONG_PTR); 
+typedef CK_RV (*CP_CloseSession)(CK_SESSION_HANDLE);
+typedef CK_RV (*CP_OpenSession)(CK_SLOT_ID,CK_FLAGS,CK_VOID_PTR,CK_RV,CK_SESSION_HANDLE_PTR);
+typedef CK_RV (*CP_SinglePartDecrypt)(CK_SESSION_HANDLE,CK_MECHANISM_PTR,CK_OBJECT_HANDLE,CK_BYTE_PTR,CK_ULONG,CK_BYTE_PTR,CK_ULONG_PTR);
+
+CP_Initialize          C_Initialize,C_Finalize; 
+CP_OpenSession         C_OpenSession; 
+CP_CloseSession        C_CloseSession; 
+CP_GetNumberOfSSLSlots CA_GetNumberOfSSLSlots;  
+CP_SinglePartDecrypt   CA_SinglePartDecrypt,CA_SinglePartSign; 
+ 
+
+
