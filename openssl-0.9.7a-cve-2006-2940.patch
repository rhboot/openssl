Dr S N Henson of the OpenSSL core team and Open Network Security
recently developed an ASN1 test suite for NISCC (www.niscc.gov.uk). When
the test suite was run against OpenSSL two denial of service
vulnerabilities were discovered.

Certain types of public key can take disproportionate amounts of time
to process. This could be used by an attacker in a denial of service attack.
CVE-2006-2940

Any code which uses OpenSSL to parse ASN1 data from untrusted sources is
affected. This includes SSL servers which enable client authentication,
and S/MIME applications.

--- openssl-0.9.7a/crypto/dsa/dsa_ossl.c.parasitic	2006-09-25 14:13:50.000000000 +0200
+++ openssl-0.9.7a/crypto/dsa/dsa_ossl.c	2006-09-25 14:13:50.000000000 +0200
@@ -275,6 +275,18 @@
 		return -1;
 		}
 
+	if (BN_num_bits(dsa->q) != 160)
+		{
+		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_BAD_Q_VALUE);
+		return -1;
+		}
+
+	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS)
+		{
+		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MODULUS_TOO_LARGE);
+		return -1;
+		}
+
 	BN_init(&u1);
 	BN_init(&u2);
 	BN_init(&t1);
--- openssl-0.9.7a/crypto/dsa/dsa_err.c.parasitic	2002-03-09 19:24:08.000000000 +0100
+++ openssl-0.9.7a/crypto/dsa/dsa_err.c	2006-09-25 14:13:50.000000000 +0200
@@ -85,8 +85,10 @@
 
 static ERR_STRING_DATA DSA_str_reasons[]=
 	{
+{DSA_R_BAD_Q_VALUE                       ,"bad q value"},
 {DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE       ,"data too large for key size"},
 {DSA_R_MISSING_PARAMETERS                ,"missing parameters"},
+{DSA_R_MODULUS_TOO_LARGE                 ,"modulus too large"},
 {0,NULL}
 	};
 
--- openssl-0.9.7a/crypto/dsa/dsa.h.parasitic	2006-09-25 14:13:50.000000000 +0200
+++ openssl-0.9.7a/crypto/dsa/dsa.h	2006-09-25 14:13:50.000000000 +0200
@@ -79,6 +79,8 @@
 # include <openssl/dh.h>
 #endif
 
+#define OPENSSL_DSA_MAX_MODULUS_BITS	10000
+
 #define DSA_FLAG_CACHE_MONT_P	0x01
 #define DSA_FLAG_NO_EXP_CONSTTIME       0x02 /* new with 0.9.7h; the built-in DSA
                                               * implementation now uses constant time
@@ -248,8 +250,10 @@
 #define DSA_F_SIG_CB					 114
 
 /* Reason codes. */
+#define DSA_R_BAD_Q_VALUE				 102
 #define DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE		 100
 #define DSA_R_MISSING_PARAMETERS			 101
+#define DSA_R_MODULUS_TOO_LARGE				 103
 
 #ifdef  __cplusplus
 }
--- openssl-0.9.7a/crypto/rsa/rsa_eay.c.parasitic	2006-09-25 14:18:00.000000000 +0200
+++ openssl-0.9.7a/crypto/rsa/rsa_eay.c	2006-09-28 11:05:46.000000000 +0200
@@ -160,6 +160,28 @@
 	unsigned char *buf=NULL;
 	BN_CTX *ctx=NULL;
 
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
+		return -1;
+		}
+
+	if (BN_ucmp(rsa->n, rsa->e) <= 0)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+		return -1;
+		}
+
+	/* for large moduli, enforce exponent limit */
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
+		{
+		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
+			{
+			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+			return -1;
+			}
+		}
+	
 	BN_init(&f);
 	BN_init(&ret);
 	if ((ctx=BN_CTX_new()) == NULL) goto err;
@@ -542,6 +564,28 @@
 	unsigned char *buf=NULL;
 	BN_CTX *ctx=NULL;
 
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
+		return -1;
+		}
+
+	if (BN_ucmp(rsa->n, rsa->e) <= 0)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+		return -1;
+		}
+
+	/* for large moduli, enforce exponent limit */
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
+		{
+		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
+			{
+			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+			return -1;
+			}
+		}
+	
 	BN_init(&f);
 	BN_init(&ret);
 	ctx=BN_CTX_new();
--- openssl-0.9.7a/crypto/rsa/rsa_err.c.parasitic	2006-09-25 14:13:50.000000000 +0200
+++ openssl-0.9.7a/crypto/rsa/rsa_err.c	2006-09-25 14:13:50.000000000 +0200
@@ -116,6 +116,7 @@
 {RSA_R_INVALID_MESSAGE_LENGTH            ,"invalid message length"},
 {RSA_R_IQMP_NOT_INVERSE_OF_Q             ,"iqmp not inverse of q"},
 {RSA_R_KEY_SIZE_TOO_SMALL                ,"key size too small"},
+{RSA_R_MODULUS_TOO_LARGE                 ,"modulus too large"},
 {RSA_R_NULL_BEFORE_BLOCK_MISSING         ,"null before block missing"},
 {RSA_R_N_DOES_NOT_EQUAL_P_Q              ,"n does not equal p q"},
 {RSA_R_OAEP_DECODING_ERROR               ,"oaep decoding error"},
--- openssl-0.9.7a/crypto/rsa/rsa.h.parasitic	2006-09-25 14:13:50.000000000 +0200
+++ openssl-0.9.7a/crypto/rsa/rsa.h	2006-09-25 14:13:50.000000000 +0200
@@ -150,6 +150,11 @@
 	BN_BLINDING *blinding;
 	};
 
+#define OPENSSL_RSA_MAX_MODULUS_BITS	16384
+
+#define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
+#define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "large" modulus only */
+
 #define RSA_3	0x3L
 #define RSA_F4	0x10001L
 
@@ -344,6 +349,7 @@
 #define RSA_R_INVALID_MESSAGE_LENGTH			 131
 #define RSA_R_IQMP_NOT_INVERSE_OF_Q			 126
 #define RSA_R_KEY_SIZE_TOO_SMALL			 120
+#define RSA_R_MODULUS_TOO_LARGE                          105
 #define RSA_R_NULL_BEFORE_BLOCK_MISSING			 113
 #define RSA_R_N_DOES_NOT_EQUAL_P_Q			 127
 #define RSA_R_OAEP_DECODING_ERROR			 121
--- openssl-0.9.7a/crypto/dh/dh.h.parasitic	2006-09-25 14:13:50.000000000 +0200
+++ openssl-0.9.7a/crypto/dh/dh.h	2006-09-25 14:13:50.000000000 +0200
@@ -70,6 +70,8 @@
 #include <openssl/crypto.h>
 #include <openssl/ossl_typ.h>
 	
+#define OPENSSL_DH_MAX_MODULUS_BITS	10000
+
 #define DH_FLAG_CACHE_MONT_P     0x01
 #define DH_FLAG_NO_EXP_CONSTTIME 0x02 /* new with 0.9.7h; the built-in DH
                                        * implementation now uses constant time
@@ -207,6 +209,7 @@
 /* Reason codes. */
 #define DH_R_BAD_GENERATOR				 101
 #define DH_R_NO_PRIVATE_VALUE				 100
+#define DH_R_MODULUS_TOO_LARGE                           103
 
 #ifdef  __cplusplus
 }
--- openssl-0.9.7a/crypto/dh/dh_key.c.parasitic	2006-09-25 14:13:50.000000000 +0200
+++ openssl-0.9.7a/crypto/dh/dh_key.c	2006-09-25 14:15:51.000000000 +0200
@@ -178,6 +178,12 @@
 	BIGNUM *tmp;
 	int ret= -1;
 
+	if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS)
+		{
+		DHerr(DH_F_DH_COMPUTE_KEY,DH_R_MODULUS_TOO_LARGE);
+		return -1;
+		}
+
 	ctx = BN_CTX_new();
 	if (ctx == NULL) goto err;
 	BN_CTX_start(ctx);
--- openssl-0.9.7a/crypto/dh/dh_err.c.parasitic	2002-03-20 17:02:45.000000000 +0100
+++ openssl-0.9.7a/crypto/dh/dh_err.c	2006-09-25 14:13:50.000000000 +0200
@@ -79,6 +79,7 @@
 	{
 {DH_R_BAD_GENERATOR                      ,"bad generator"},
 {DH_R_NO_PRIVATE_VALUE                   ,"no private value"},
+{DH_R_MODULUS_TOO_LARGE                  ,"modulus too large"},
 {0,NULL}
 	};
 
